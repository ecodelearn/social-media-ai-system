#!/usr/bin/env python3
"""
Demo da Fase 3 - Orquestra√ß√£o Completa End-to-End

Este demo demonstra o sistema completo funcionando:
1. üîç Pesquisa via Perplexity MCP
2. ü§ñ Cria√ß√£o de conte√∫do via 4 agentes CrewAI
3. üì± Envio autom√°tico via WhatsApp MCP

FASE 3: ORCHESTRATION - 100% IMPLEMENTADA

Autor: Sistema de IA Colaborativo
Vers√£o: 1.0.0
"""

import asyncio
import logging
import time
import json
from datetime import datetime
from typing import Dict, Any, List

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('phase3_demo.log')
    ]
)

logger = logging.getLogger(__name__)

# Imports do sistema
try:
    from core.workflows import content_workflow, create_content_complete, get_workflow_statistics
    from core.real_mcp_integrations import real_mcp_integrations
    from core.agents import social_agents, get_agents_status, get_agents_info
    from core.llm_manager import llm_manager
    from config.settings import SystemSettings
    SYSTEM_AVAILABLE = True
except ImportError as e:
    logger.error(f"Erro ao importar sistema: {e}")
    SYSTEM_AVAILABLE = False

class Phase3Demo:
    """Demonstra√ß√£o completa da Fase 3 - Orquestra√ß√£o End-to-End"""
    
    def __init__(self):
        """Inicializa o demo"""
        self.logger = logging.getLogger(__name__)
        
        if not SYSTEM_AVAILABLE:
            raise RuntimeError("Sistema n√£o dispon√≠vel para demonstra√ß√£o")
        
        # Componentes do sistema
        self.workflow_system = content_workflow
        self.mcp_integrations = real_mcp_integrations
        self.agents_system = social_agents
        
        # Configura√ß√µes do demo
        self.demo_topics = [
            "Intelig√™ncia Artificial e Futuro do Trabalho",
            "Marketing Digital para Pequenas Empresas",
            "Sustentabilidade e Tecnologia Verde",
            "Transforma√ß√£o Digital nas Empresas",
            "Empreendedorismo Inovador 2025"
        ]
        
        # Resultados dos testes
        self.demo_results = []
        
        self.logger.info("üé¨ Phase 3 Demo System inicializado")
    
    async def run_complete_demo(self) -> Dict[str, Any]:
        """Executa demonstra√ß√£o completa da Fase 3"""
        demo_start = time.time()
        
        try:
            self.logger.info("üöÄ Iniciando demonstra√ß√£o completa da Fase 3")
            
            # === VERIFICA√á√ïES INICIAIS ===
            self.logger.info("üîß Executando verifica√ß√µes iniciais...")
            system_status = await self._check_system_status()
            
            if not system_status["ready"]:
                raise RuntimeError(f"Sistema n√£o est√° pronto: {system_status}")
            
            # === DEMO 1: WORKFLOW B√ÅSICO (SEM ENVIO) ===
            self.logger.info("üìù Demo 1: Workflow b√°sico de cria√ß√£o de conte√∫do...")
            basic_result = await self._demo_basic_workflow()
            
            # === DEMO 2: WORKFLOW COMPLETO COM AUTO-ENVIO ===
            self.logger.info("üì± Demo 2: Workflow completo com envio autom√°tico...")
            complete_result = await self._demo_complete_workflow()
            
            # === DEMO 3: M√öLTIPLOS WORKFLOWS PARALELOS ===
            self.logger.info("‚ö° Demo 3: M√∫ltiplos workflows em paralelo...")
            parallel_result = await self._demo_parallel_workflows()
            
            # === AN√ÅLISE DOS RESULTADOS ===
            self.logger.info("üìä Analisando resultados da demonstra√ß√£o...")
            analysis = await self._analyze_demo_results()
            
            # === ESTAT√çSTICAS FINAIS ===
            final_stats = await self._get_final_statistics()
            
            demo_time = time.time() - demo_start
            
            demo_summary = {
                "success": True,
                "execution_time": demo_time,
                "system_status": system_status,
                "demo_results": {
                    "basic_workflow": basic_result,
                    "complete_workflow": complete_result,
                    "parallel_workflows": parallel_result
                },
                "analysis": analysis,
                "final_statistics": final_stats,
                "timestamp": datetime.now().isoformat()
            }
            
            self.logger.info(f"‚úÖ Demonstra√ß√£o da Fase 3 conclu√≠da em {demo_time:.2f}s")
            return demo_summary
            
        except Exception as e:
            demo_time = time.time() - demo_start
            error_summary = {
                "success": False,
                "error": str(e),
                "execution_time": demo_time,
                "timestamp": datetime.now().isoformat()
            }
            
            self.logger.error(f"‚ùå Erro na demonstra√ß√£o: {e}")
            return error_summary
    
    async def _check_system_status(self) -> Dict[str, Any]:
        """Verifica status de todos os componentes do sistema"""
        status = {
            "ready": False,
            "components": {},
            "errors": []
        }
        
        try:
            # Verificar LLM Manager
            llm_status = llm_manager.get_provider_status()
            status["components"]["llm_manager"] = {
                "available": bool(llm_status),
                "providers": llm_status
            }
            
            # Verificar Agentes
            agents_status = get_agents_status()
            agents_info = get_agents_info()
            status["components"]["agents"] = {
                "available": all(agents_status.values()),
                "agents_status": agents_status,
                "agents_info": agents_info
            }
            
            # Verificar MCP Integrations
            mcp_connections = await self.mcp_integrations.test_connections()
            mcp_stats = self.mcp_integrations.get_usage_stats()
            status["components"]["mcp_integrations"] = {
                "available": any(mcp_connections.values()),
                "connections": mcp_connections,
                "usage_stats": mcp_stats
            }
            
            # Verificar Workflow System
            workflow_stats = get_workflow_statistics()
            status["components"]["workflow_system"] = {
                "available": True,
                "statistics": workflow_stats
            }
            
            # Determinar se o sistema est√° pronto
            ready_checks = [
                status["components"]["llm_manager"]["available"],
                status["components"]["agents"]["available"],
                status["components"]["mcp_integrations"]["available"],
                status["components"]["workflow_system"]["available"]
            ]
            
            status["ready"] = all(ready_checks)
            
            if not status["ready"]:
                status["errors"].append("Nem todos os componentes est√£o dispon√≠veis")
            
            self.logger.info(f"üîç Status do sistema: {'‚úÖ Pronto' if status['ready'] else '‚ùå N√£o pronto'}")
            
        except Exception as e:
            status["errors"].append(f"Erro na verifica√ß√£o: {e}")
            self.logger.error(f"‚ùå Erro na verifica√ß√£o do sistema: {e}")
        
        return status
    
    async def _demo_basic_workflow(self) -> Dict[str, Any]:
        """Demonstra workflow b√°sico sem envio autom√°tico"""
        topic = self.demo_topics[0]
        
        try:
            self.logger.info(f"üéØ Criando conte√∫do para: {topic}")
            
            result = await create_content_complete(
                topic=topic,
                platforms=["instagram", "linkedin", "whatsapp"],
                target_audience="Profissionais de tecnologia",
                objective="Educa√ß√£o e engajamento",
                tone="Profissional e acess√≠vel",
                auto_send=False  # N√£o enviar automaticamente
            )
            
            demo_result = {
                "success": result.success,
                "topic": topic,
                "execution_time": result.execution_time,
                "status": result.status.value,
                "content_created": bool(result.crew_result and result.crew_result.final_content),
                "research_completed": bool(result.perplexity_research and result.perplexity_research.success),
                "content_length": len(result.crew_result.final_content) if result.crew_result else 0
            }
            
            self.demo_results.append(("basic_workflow", demo_result))
            
            if result.success:
                self.logger.info(f"‚úÖ Workflow b√°sico conclu√≠do: {result.status.value}")
            else:
                self.logger.error(f"‚ùå Falha no workflow b√°sico: {result.error_message}")
            
            return demo_result
            
        except Exception as e:
            error_result = {
                "success": False,
                "topic": topic,
                "error": str(e)
            }
            self.logger.error(f"‚ùå Erro no demo b√°sico: {e}")
            return error_result
    
    async def _demo_complete_workflow(self) -> Dict[str, Any]:
        """Demonstra workflow completo com envio autom√°tico"""
        topic = self.demo_topics[1]
        
        try:
            self.logger.info(f"üéØ Criando e enviando conte√∫do para: {topic}")
            
            result = await create_content_complete(
                topic=topic,
                platforms=["whatsapp", "instagram"],
                target_audience="Empreendedores e pequenos empres√°rios",
                objective="Gerar leads e compartilhamentos",
                tone="Amig√°vel e pr√°tico",
                auto_send=True,  # Enviar automaticamente
                max_groups=2    # M√°ximo 2 grupos para o demo
            )
            
            demo_result = {
                "success": result.success,
                "topic": topic,
                "execution_time": result.execution_time,
                "status": result.status.value,
                "content_created": bool(result.crew_result and result.crew_result.final_content),
                "research_completed": bool(result.perplexity_research and result.perplexity_research.success),
                "messages_sent": len(result.whatsapp_results),
                "successful_sends": sum(1 for r in result.whatsapp_results if r.success),
                "groups_targeted": len(result.selected_groups),
                "group_names": [g.name for g in result.selected_groups]
            }
            
            self.demo_results.append(("complete_workflow", demo_result))
            
            if result.success:
                self.logger.info(
                    f"‚úÖ Workflow completo conclu√≠do: "
                    f"{demo_result['successful_sends']}/{demo_result['messages_sent']} mensagens enviadas"
                )
            else:
                self.logger.error(f"‚ùå Falha no workflow completo: {result.error_message}")
            
            return demo_result
            
        except Exception as e:
            error_result = {
                "success": False,
                "topic": topic,
                "error": str(e)
            }
            self.logger.error(f"‚ùå Erro no demo completo: {e}")
            return error_result
    
    async def _demo_parallel_workflows(self) -> Dict[str, Any]:
        """Demonstra m√∫ltiplos workflows executando em paralelo"""
        parallel_topics = self.demo_topics[2:5]  # 3 t√≥picos
        
        try:
            self.logger.info(f"‚ö° Executando {len(parallel_topics)} workflows em paralelo...")
            
            # Criar tasks para execu√ß√£o paralela
            tasks = []
            for i, topic in enumerate(parallel_topics):
                task = create_content_complete(
                    topic=topic,
                    platforms=["instagram", "whatsapp"],
                    target_audience="P√∫blico geral interessado em inova√ß√£o",
                    objective="Viraliza√ß√£o e engajamento",
                    auto_send=False,  # N√£o enviar para n√£o sobrecarregar
                    workflow_id=f"parallel_{i+1}_{int(time.time())}"
                )
                tasks.append(task)
            
            # Executar todos em paralelo
            start_time = time.time()
            results = await asyncio.gather(*tasks, return_exceptions=True)
            parallel_time = time.time() - start_time
            
            # Analisar resultados
            successful_workflows = 0
            failed_workflows = 0
            total_content_length = 0
            
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    failed_workflows += 1
                    self.logger.error(f"‚ùå Workflow paralelo {i+1} falhou: {result}")
                else:
                    if result.success:
                        successful_workflows += 1
                        if result.crew_result and result.crew_result.final_content:
                            total_content_length += len(result.crew_result.final_content)
                    else:
                        failed_workflows += 1
            
            demo_result = {
                "success": successful_workflows > 0,
                "topics": parallel_topics,
                "execution_time": parallel_time,
                "total_workflows": len(parallel_topics),
                "successful_workflows": successful_workflows,
                "failed_workflows": failed_workflows,
                "total_content_length": total_content_length,
                "avg_execution_time": parallel_time / len(parallel_topics)
            }
            
            self.demo_results.append(("parallel_workflows", demo_result))
            
            self.logger.info(
                f"‚ö° Workflows paralelos conclu√≠dos: "
                f"{successful_workflows}/{len(parallel_topics)} sucessos em {parallel_time:.2f}s"
            )
            
            return demo_result
            
        except Exception as e:
            error_result = {
                "success": False,
                "topics": parallel_topics,
                "error": str(e)
            }
            self.logger.error(f"‚ùå Erro nos workflows paralelos: {e}")
            return error_result
    
    async def _analyze_demo_results(self) -> Dict[str, Any]:
        """Analisa os resultados de todos os demos"""
        analysis = {
            "total_demos": len(self.demo_results),
            "successful_demos": 0,
            "failed_demos": 0,
            "performance_metrics": {},
            "quality_assessment": {},
            "recommendations": []
        }
        
        try:
            # Contar sucessos e falhas
            for demo_type, result in self.demo_results:
                if result.get("success", False):
                    analysis["successful_demos"] += 1
                else:
                    analysis["failed_demos"] += 1
            
            # Calcular m√©tricas de performance
            execution_times = [
                result.get("execution_time", 0) 
                for _, result in self.demo_results 
                if "execution_time" in result
            ]
            
            if execution_times:
                analysis["performance_metrics"] = {
                    "avg_execution_time": sum(execution_times) / len(execution_times),
                    "min_execution_time": min(execution_times),
                    "max_execution_time": max(execution_times),
                    "total_execution_time": sum(execution_times)
                }
            
            # Avaliar qualidade
            success_rate = analysis["successful_demos"] / max(analysis["total_demos"], 1)
            analysis["quality_assessment"] = {
                "success_rate": success_rate * 100,
                "system_reliability": "High" if success_rate >= 0.8 else "Medium" if success_rate >= 0.5 else "Low",
                "ready_for_production": success_rate >= 0.8
            }
            
            # Gerar recomenda√ß√µes
            if success_rate >= 0.8:
                analysis["recommendations"].append("‚úÖ Sistema pronto para produ√ß√£o")
                analysis["recommendations"].append("‚úÖ Fase 3 completamente implementada")
            elif success_rate >= 0.5:
                analysis["recommendations"].append("‚ö†Ô∏è Sistema funcional mas precisa de ajustes")
                analysis["recommendations"].append("üîß Revisar componentes com falhas")
            else:
                analysis["recommendations"].append("‚ùå Sistema requer corre√ß√µes significativas")
                analysis["recommendations"].append("üîß Revisar todas as integra√ß√µes")
            
            self.logger.info(f"üìä An√°lise conclu√≠da: {success_rate*100:.1f}% de sucesso")
            
        except Exception as e:
            analysis["error"] = str(e)
            self.logger.error(f"‚ùå Erro na an√°lise: {e}")
        
        return analysis
    
    async def _get_final_statistics(self) -> Dict[str, Any]:
        """Obt√©m estat√≠sticas finais de todos os componentes"""
        stats = {}
        
        try:
            # Estat√≠sticas do Workflow
            stats["workflow"] = get_workflow_statistics()
            
            # Estat√≠sticas MCP
            stats["mcp"] = self.mcp_integrations.get_usage_stats()
            
            # Status dos Agentes
            stats["agents"] = {
                "status": get_agents_status(),
                "info": get_agents_info()
            }
            
            # Estat√≠sticas do Demo
            stats["demo"] = {
                "total_topics_tested": len(set(self.demo_topics)),
                "total_demos_executed": len(self.demo_results),
                "demo_results": self.demo_results
            }
            
        except Exception as e:
            stats["error"] = str(e)
            self.logger.error(f"‚ùå Erro ao obter estat√≠sticas: {e}")
        
        return stats
    
    def save_demo_report(self, results: Dict[str, Any], filename: str = None) -> str:
        """Salva relat√≥rio detalhado do demo"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"phase3_demo_report_{timestamp}.json"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False, default=str)
            
            self.logger.info(f"üìÑ Relat√≥rio salvo: {filename}")
            return filename
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao salvar relat√≥rio: {e}")
            return ""

async def main():
    """Fun√ß√£o principal do demo"""
    print("üé¨ DEMO FASE 3 - ORQUESTRA√á√ÉO COMPLETA END-TO-END")
    print("=" * 60)
    print()
    
    try:
        # Criar inst√¢ncia do demo
        demo = Phase3Demo()
        
        # Executar demonstra√ß√£o completa
        print("üöÄ Iniciando demonstra√ß√£o da Fase 3...")
        results = await demo.run_complete_demo()
        
        # Exibir resumo
        print("\nüìä RESUMO DA DEMONSTRA√á√ÉO")
        print("-" * 40)
        
        if results["success"]:
            print("‚úÖ Status: SUCESSO")
            print(f"‚è±Ô∏è  Tempo total: {results['execution_time']:.2f}s")
            
            # Exibir resultados dos demos
            demo_results = results["demo_results"]
            
            print(f"\nüìù Demo B√°sico: {'‚úÖ' if demo_results['basic_workflow']['success'] else '‚ùå'}")
            print(f"üì± Demo Completo: {'‚úÖ' if demo_results['complete_workflow']['success'] else '‚ùå'}")
            print(f"‚ö° Demo Paralelo: {'‚úÖ' if demo_results['parallel_workflows']['success'] else '‚ùå'}")
            
            # Exibir an√°lise
            analysis = results["analysis"]
            print(f"\nüìà Taxa de Sucesso: {analysis['quality_assessment']['success_rate']:.1f}%")
            print(f"üéØ Confiabilidade: {analysis['quality_assessment']['system_reliability']}")
            print(f"üöÄ Pronto para Produ√ß√£o: {'‚úÖ' if analysis['quality_assessment']['ready_for_production'] else '‚ùå'}")
            
            # Exibir recomenda√ß√µes
            print("\nüí° RECOMENDA√á√ïES:")
            for rec in analysis["recommendations"]:
                print(f"   {rec}")
            
        else:
            print("‚ùå Status: FALHA")
            print(f"‚ùå Erro: {results.get('error', 'Erro desconhecido')}")
        
        # Salvar relat√≥rio
        report_file = demo.save_demo_report(results)
        if report_file:
            print(f"\nüìÑ Relat√≥rio detalhado salvo: {report_file}")
        
        print("\n" + "=" * 60)
        print("üé¨ DEMONSTRA√á√ÉO DA FASE 3 CONCLU√çDA")
        
        # Retornar c√≥digo de sa√≠da apropriado
        return 0 if results["success"] else 1
        
    except Exception as e:
        print(f"\n‚ùå ERRO CR√çTICO: {e}")
        logger.error(f"Erro cr√≠tico no demo: {e}")
        return 1

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        exit(exit_code)
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Demo interrompido pelo usu√°rio")
        exit(1)
    except Exception as e:
        print(f"\nüí• Erro fatal: {e}")
        exit(1)
