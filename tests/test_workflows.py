#!/usr/bin/env python3
"""
Testes de Workflows - Social Media AI System

Este mÃ³dulo contÃ©m testes abrangentes para validar o funcionamento
dos workflows de orquestraÃ§Ã£o e integraÃ§Ã£o entre agentes.

Testes incluem:
- CriaÃ§Ã£o e configuraÃ§Ã£o de workflows
- ExecuÃ§Ã£o de workflows completos
- Sistema de recomendaÃ§Ã£o de workflows
- MÃ©tricas e estatÃ­sticas
- IntegraÃ§Ã£o com orquestrador

Autor: Sistema de IA Colaborativo
VersÃ£o: 1.0.0 - Fase 3
"""

import pytest
import asyncio
import logging
from typing import Dict, List, Any
from datetime import datetime, timedelta
import time

# Configurar logging para testes
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Imports do sistema
from config.settings import SystemSettings
from core.agents import ContentRequest, CrewResult, AgentResult
from core.orchestrator import (
    ContentOrchestrator,
    OrchestrationStatus,
    ApprovalDecision,
    ExecutionContext,
    content_orchestrator,
    create_content_orchestrated
)
from core.workflows import (
    WorkflowManager,
    WorkflowType,
    WorkflowStep,
    WorkflowConfig,
    WorkflowExecution,
    workflow_manager,
    get_recommended_workflow,
    get_available_workflows,
    create_custom_workflow
)

class TestWorkflowManager:
    """Testes para o gerenciador de workflows"""
    
    @pytest.fixture
    def sample_request(self) -> ContentRequest:
        """SolicitaÃ§Ã£o de exemplo para testes"""
        return ContentRequest(
            topic="EstratÃ©gias de Marketing Digital 2024",
            platforms=["instagram", "linkedin"],
            target_audience="Profissionais de marketing e empreendedores",
            objective="Educar e gerar leads qualificados",
            tone="Profissional e inspirador",
            special_instructions="Inclua estatÃ­sticas recentes, tendÃªncias e casos prÃ¡ticos"
        )
    
    @pytest.fixture
    def urgent_request(self) -> ContentRequest:
        """SolicitaÃ§Ã£o urgente para testes"""
        return ContentRequest(
            topic="Comunicado sobre nova funcionalidade",
            platforms=["whatsapp"],
            target_audience="UsuÃ¡rios existentes",
            objective="Informar rapidamente",
            tone="Direto e claro",
            deadline=datetime.now() + timedelta(hours=1)
        )
    
    @pytest.fixture
    def premium_request(self) -> ContentRequest:
        """SolicitaÃ§Ã£o premium para testes"""
        return ContentRequest(
            topic="LanÃ§amento oficial da campanha premium da marca",
            platforms=["instagram", "linkedin", "facebook"],
            target_audience="Clientes premium e prospects qualificados",
            objective="Maximizar conversÃµes e impacto da marca",
            tone="Premium e exclusivo",
            special_instructions="Campanha estratÃ©gica com mÃºltiplas validaÃ§Ãµes e alta qualidade visual"
        )
    
    def test_workflow_manager_initialization(self):
        """Testa inicializaÃ§Ã£o do gerenciador de workflows"""
        logger.info("ðŸ§ª Testando inicializaÃ§Ã£o do WorkflowManager...")
        
        # Verificar se foi inicializado
        assert workflow_manager is not None
        
        # Verificar workflows predefinidos
        assert len(workflow_manager.predefined_workflows) == 3
        assert WorkflowType.STANDARD in workflow_manager.predefined_workflows
        assert WorkflowType.EXPRESS in workflow_manager.predefined_workflows
        assert WorkflowType.PREMIUM in workflow_manager.predefined_workflows
        
        # Verificar estruturas internas
        assert isinstance(workflow_manager.custom_workflows, dict)
        assert isinstance(workflow_manager.active_executions, dict)
        assert isinstance(workflow_manager.workflow_stats, dict)
        
        logger.info("âœ… WorkflowManager inicializado corretamente")
    
    def test_predefined_workflows_creation(self):
        """Testa criaÃ§Ã£o dos workflows predefinidos"""
        logger.info("ðŸ§ª Testando workflows predefinidos...")
        
        workflows = workflow_manager.predefined_workflows
        
        # Testar Standard Workflow
        standard = workflows[WorkflowType.STANDARD]
        assert standard.name == "Standard Content Creation"
        assert len(standard.steps) == 4
        assert standard.estimated_time == 180
        assert standard.quality_level == "standard"
        assert "instagram" in standard.platforms_supported
        
        # Testar Express Workflow
        express = workflows[WorkflowType.EXPRESS]
        assert express.name == "Express Content Creation"
        assert len(express.steps) == 2
        assert standard.estimated_time > express.estimated_time
        assert express.quality_level == "basic"
        
        # Testar Premium Workflow
        premium = workflows[WorkflowType.PREMIUM]
        assert premium.name == "Premium Content Creation"
        assert len(premium.steps) >= 4
        assert premium.estimated_time >= standard.estimated_time
        assert premium.quality_level == "premium"
        
        logger.info("âœ… Workflows predefinidos criados corretamente")
    
    def test_workflow_steps_configuration(self):
        """Testa configuraÃ§Ã£o dos passos dos workflows"""
        logger.info("ðŸ§ª Testando configuraÃ§Ã£o dos passos...")
        
        workflows = workflow_manager.predefined_workflows
        
        # Standard deve ter sequÃªncia completa
        standard_steps = workflows[WorkflowType.STANDARD].steps
        expected_standard = [
            WorkflowStep.RESEARCH,
            WorkflowStep.WRITING,
            WorkflowStep.VISUAL,
            WorkflowStep.EDITING
        ]
        assert standard_steps == expected_standard
        
        # Express deve ser minimalista
        express_steps = workflows[WorkflowType.EXPRESS].steps
        assert WorkflowStep.WRITING in express_steps
        assert WorkflowStep.EDITING in express_steps
        assert WorkflowStep.RESEARCH not in express_steps
        
        # Premium deve ter passos extras
        premium_steps = workflows[WorkflowType.PREMIUM].steps
        assert len(premium_steps) > len(standard_steps)
        assert WorkflowStep.VALIDATION in premium_steps or WorkflowStep.REVIEW in premium_steps
        
        logger.info("âœ… Passos dos workflows configurados corretamente")
    
    def test_workflow_recommendation_logic(self, sample_request, urgent_request, premium_request):
        """Testa lÃ³gica de recomendaÃ§Ã£o de workflows"""
        logger.info("ðŸ§ª Testando lÃ³gica de recomendaÃ§Ã£o...")
        
        # Teste com prioridade balanceada
        balanced_workflow = workflow_manager.get_recommended_workflow(sample_request, "balanced")
        assert balanced_workflow.name == "Standard Content Creation"
        
        # Teste com prioridade de velocidade
        speed_workflow = workflow_manager.get_recommended_workflow(urgent_request, "speed")
        assert speed_workflow.quality_level in ["basic", "standard"]
        assert speed_workflow.estimated_time <= 120
        
        # Teste com prioridade de qualidade
        quality_workflow = workflow_manager.get_recommended_workflow(premium_request, "quality")
        assert quality_workflow.quality_level in ["standard", "premium"]
        
        logger.info("âœ… LÃ³gica de recomendaÃ§Ã£o funcionando")
    
    def test_content_complexity_calculation(self):
        """Testa cÃ¡lculo de complexidade do conteÃºdo"""
        logger.info("ðŸ§ª Testando cÃ¡lculo de complexidade...")
        
        # ConteÃºdo simples
        simple_request = ContentRequest(
            topic="Dica rÃ¡pida",
            platforms=["whatsapp"],
            target_audience="Geral",
            objective="Compartilhar"
        )
        simple_complexity = workflow_manager._calculate_content_complexity(simple_request)
        assert 0.0 <= simple_complexity <= 0.4
        
        # ConteÃºdo complexo
        complex_request = ContentRequest(
            topic="AnÃ¡lise estratÃ©gica detalhada de research cientÃ­fico e comparativo tÃ©cnico",
            platforms=["instagram", "linkedin", "facebook", "twitter"],
            target_audience="Especialistas em mÃºltiplas Ã¡reas",
            objective="EducaÃ§Ã£o tÃ©cnica avanÃ§ada",
            special_instructions="Inclua anÃ¡lises estatÃ­sticas detalhadas com mÃºltiplas referÃªncias e estudos comparativos entre diferentes metodologias de pesquisa aplicada"
        )
        complex_complexity = workflow_manager._calculate_content_complexity(complex_request)
        assert 0.6 <= complex_complexity <= 1.0
        
        logger.info("âœ… CÃ¡lculo de complexidade funcionando")
    
    def test_urgency_calculation(self):
        """Testa cÃ¡lculo de urgÃªncia"""
        logger.info("ðŸ§ª Testando cÃ¡lculo de urgÃªncia...")
        
        # Sem deadline (urgÃªncia padrÃ£o)
        no_deadline = ContentRequest(
            topic="Teste",
            platforms=["instagram"],
            target_audience="Teste",
            objective="Teste"
        )
        default_urgency = workflow_manager._calculate_urgency(no_deadline)
        assert default_urgency == 0.3
        
        # Muito urgente (1 hora)
        very_urgent = ContentRequest(
            topic="Teste",
            platforms=["instagram"],
            target_audience="Teste",
            objective="Teste",
            deadline=datetime.now() + timedelta(minutes=30)
        )
        high_urgency = workflow_manager._calculate_urgency(very_urgent)
        assert high_urgency >= 0.8
        
        # NÃ£o urgente (1 semana)
        not_urgent = ContentRequest(
            topic="Teste",
            platforms=["instagram"],
            target_audience="Teste",
            objective="Teste",
            deadline=datetime.now() + timedelta(days=7)
        )
        low_urgency = workflow_manager._calculate_urgency(not_urgent)
        assert low_urgency <= 0.3
        
        logger.info("âœ… CÃ¡lculo de urgÃªncia funcionando")
    
    def test_quality_requirement_assessment(self):
        """Testa avaliaÃ§Ã£o de requisito de qualidade"""
        logger.info("ðŸ§ª Testando avaliaÃ§Ã£o de qualidade...")
        
        # Baixa qualidade
        basic_request = ContentRequest(
            topic="Post casual",
            platforms=["whatsapp"],
            target_audience="Amigos",
            objective="DiversÃ£o"
        )
        basic_quality = workflow_manager._assess_quality_requirement(basic_request)
        assert basic_quality <= 0.6
        
        # Alta qualidade
        premium_request = ContentRequest(
            topic="LanÃ§amento oficial da campanha premium corporativa da marca",
            platforms=["linkedin", "instagram"],
            target_audience="Executivos C-level",
            objective="Maximizar conversÃµes estratÃ©gicas",
            special_instructions="Campanha profissional premium para lanÃ§amento oficial"
        )
        premium_quality = workflow_manager._assess_quality_requirement(premium_request)
        assert premium_quality >= 0.7
        
        logger.info("âœ… AvaliaÃ§Ã£o de qualidade funcionando")
    
    def test_custom_workflow_creation(self):
        """Testa criaÃ§Ã£o de workflow customizado"""
        logger.info("ðŸ§ª Testando criaÃ§Ã£o de workflow customizado...")
        
        # Criar workflow customizado
        custom_id = workflow_manager.create_custom_workflow(
            name="Workflow de Teste",
            description="Workflow criado para testes",
            steps=[WorkflowStep.RESEARCH, WorkflowStep.WRITING],
            agents_required=["researcher", "writer"],
            estimated_time=90,
            quality_level="standard",
            platforms_supported=["instagram", "whatsapp"],
            use_cases=["Teste automatizado"]
        )
        
        # Verificar se foi criado
        assert custom_id.startswith("custom_")
        assert custom_id in workflow_manager.custom_workflows
        
        # Verificar configuraÃ§Ã£o
        custom_workflow = workflow_manager.custom_workflows[custom_id]
        assert custom_workflow.name == "Workflow de Teste"
        assert len(custom_workflow.steps) == 2
        assert custom_workflow.estimated_time == 90
        
        logger.info("âœ… Workflow customizado criado")
    
    def test_workflow_recommendations_list(self, sample_request):
        """Testa lista de recomendaÃ§Ãµes de workflows"""
        logger.info("ðŸ§ª Testando lista de recomendaÃ§Ãµes...")
        
        recommendations = workflow_manager.get_workflow_recommendations(sample_request)
        
        # Verificar estrutura
        assert isinstance(recommendations, list)
        assert len(recommendations) == 3  # Standard, Express, Premium
        
        # Verificar ordenaÃ§Ã£o por score
        scores = [rec["suitability_score"] for rec in recommendations]
        assert scores == sorted(scores, reverse=True)
        
        # Verificar estrutura de cada recomendaÃ§Ã£o
        for rec in recommendations:
            assert "workflow_type" in rec
            assert "config" in rec
            assert "suitability_score" in rec
            assert "estimated_time" in rec
            assert "quality_level" in rec
            assert "platforms_supported" in rec
            
            # Verificar valores vÃ¡lidos
            assert 0.0 <= rec["suitability_score"] <= 1.0
            assert rec["estimated_time"] > 0
        
        logger.info("âœ… Lista de recomendaÃ§Ãµes funcionando")
    
    def test_workflow_suitability_calculation(self, sample_request):
        """Testa cÃ¡lculo de adequaÃ§Ã£o de workflow"""
        logger.info("ðŸ§ª Testando cÃ¡lculo de adequaÃ§Ã£o...")
        
        # Testar adequaÃ§Ã£o do Standard
        standard_config = workflow_manager.predefined_workflows[WorkflowType.STANDARD]
        standard_score = workflow_manager._calculate_workflow_suitability(standard_config, sample_request)
        
        # Testar adequaÃ§Ã£o do Express
        express_config = workflow_manager.predefined_workflows[WorkflowType.EXPRESS]
        express_score = workflow_manager._calculate_workflow_suitability(express_config, sample_request)
        
        # Verificar que scores sÃ£o vÃ¡lidos
        assert 0.0 <= standard_score <= 1.0
        assert 0.0 <= express_score <= 1.0
        
        # Para uma solicitaÃ§Ã£o balanceada, Standard deve ter score alto
        assert standard_score >= 0.5
        
        logger.info("âœ… CÃ¡lculo de adequaÃ§Ã£o funcionando")

class TestWorkflowExecution:
    """Testes de execuÃ§Ã£o de workflows"""
    
    @pytest.fixture
    def simple_request(self) -> ContentRequest:
        """SolicitaÃ§Ã£o simples para testes de execuÃ§Ã£o"""
        return ContentRequest(
            topic="Dicas de produtividade para trabalho remoto",
            platforms=["whatsapp"],
            target_audience="Profissionais remotos",
            objective="Compartilhar conhecimento Ãºtil"
        )
    
    def test_workflow_execution_creation(self, simple_request):
        """Testa criaÃ§Ã£o de execuÃ§Ã£o de workflow"""
        logger.info("ðŸ§ª Testando criaÃ§Ã£o de execuÃ§Ã£o...")
        
        # Obter workflow recomendado
        workflow_config = workflow_manager.get_recommended_workflow(simple_request)
        
        # Criar contexto de execuÃ§Ã£o
        context = ExecutionContext(
            request=simple_request,
            status=OrchestrationStatus.IDLE
        )
        
        # Iniciar execuÃ§Ã£o
        execution_id = workflow_manager.start_workflow_execution(workflow_config, context)
        
        # Verificar se foi criado
        assert execution_id.startswith("wf_")
        assert execution_id in workflow_manager.active_executions
        
        # Verificar estrutura da execuÃ§Ã£o
        execution = workflow_manager.active_executions[execution_id]
        assert execution.workflow_id == execution_id
        assert execution.config == workflow_config
        assert execution.context == context
        assert execution.start_time is not None
        assert execution.estimated_completion is not None
        
        logger.info("âœ… ExecuÃ§Ã£o de workflow criada")
    
    def test_workflow_progress_tracking(self, simple_request):
        """Testa acompanhamento de progresso"""
        logger.info("ðŸ§ª Testando acompanhamento de progresso...")
        
        # Criar execuÃ§Ã£o
        workflow_config = workflow_manager.get_recommended_workflow(simple_request)
        context = ExecutionContext(request=simple_request, status=OrchestrationStatus.IDLE)
        execution_id = workflow_manager.start_workflow_execution(workflow_config, context)
        
        # Verificar progresso inicial
        progress = workflow_manager.get_workflow_progress(execution_id)
        assert progress is not None
        assert progress["execution_id"] == execution_id
        assert progress["progress_percentage"] == 0.0
        assert progress["total_steps"] == len(workflow_config.steps)
        
        # Simular conclusÃ£o de um passo
        if workflow_config.steps:
            first_step = workflow_config.steps[0]
            mock_result = AgentResult(
                agent_name="test",
                success=True,
                content="Resultado de teste",
                metadata={},
                execution_time=1.0
            )
            
            workflow_manager.complete_workflow_step(execution_id, first_step, mock_result)
            
            # Verificar progresso atualizado
            updated_progress = workflow_manager.get_workflow_progress(execution_id)
            assert updated_progress["progress_percentage"] > 0.0
            assert len(updated_progress["completed_steps"]) == 1
        
        logger.info("âœ… Acompanhamento de progresso funcionando")
    
    def test_workflow_step_completion(self, simple_request):
        """Testa conclusÃ£o de passos do workflow"""
        logger.info("ðŸ§ª Testando conclusÃ£o de passos...")
        
        # Criar execuÃ§Ã£o
        workflow_config = workflow_manager.get_recommended_workflow(simple_request)
        context = ExecutionContext(request=simple_request, status=OrchestrationStatus.IDLE)
        execution_id = workflow_manager.start_workflow_execution(workflow_config, context)
        
        execution = workflow_manager.active_executions[execution_id]
        initial_completed = len(execution.completed_steps)
        
        # Simular conclusÃ£o de passo
        if workflow_config.steps:
            step = workflow_config.steps[0]
            result = AgentResult(
                agent_name="test_agent",
                success=True,
                content="ConteÃºdo de teste",
                metadata={"test": True},
                execution_time=2.5
            )
            
            workflow_manager.complete_workflow_step(execution_id, step, result)
            
            # Verificar que o passo foi marcado como concluÃ­do
            assert len(execution.completed_steps) == initial_completed + 1
            assert step in execution.completed_steps
            assert step.value in execution.step_results
            assert execution.step_results[step.value] == result
        
        logger.info("âœ… ConclusÃ£o de passos funcionando")

class TestWorkflowIntegration:
    """Testes de integraÃ§Ã£o entre workflows e orquestrador"""
    
    @pytest.fixture
    def integration_request(self) -> ContentRequest:
        """SolicitaÃ§Ã£o para testes de integraÃ§Ã£o"""
        return ContentRequest(
            topic="BenefÃ­cios da automaÃ§Ã£o no marketing",
            platforms=["instagram", "linkedin"],
            target_audience="Profissionais de marketing",
            objective="Educar sobre automaÃ§Ã£o"
        )
    
    def test_orchestrator_initialization(self):
        """Testa inicializaÃ§Ã£o do orquestrador"""
        logger.info("ðŸ§ª Testando inicializaÃ§Ã£o do orquestrador...")
        
        # Verificar se foi inicializado
        assert content_orchestrator is not None
        
        # Verificar configuraÃ§Ãµes
        assert hasattr(content_orchestrator, 'max_concurrent_executions')
        assert hasattr(content_orchestrator, 'default_timeout')
        assert hasattr(content_orchestrator, 'quality_threshold')
        
        # Verificar estruturas internas
        assert isinstance(content_orchestrator.active_executions, dict)
        assert isinstance(content_orchestrator.execution_history, list)
        assert hasattr(content_orchestrator, 'metrics')
        
        logger.info("âœ… Orquestrador inicializado corretamente")
    
    def test_workflow_orchestrator_integration(self, integration_request):
        """Testa integraÃ§Ã£o entre workflow e orquestrador"""
        logger.info("ðŸ§ª Testando integraÃ§Ã£o workflow-orquestrador...")
        
        # Obter workflow recomendado
        recommended = get_recommended_workflow(integration_request)
        assert recommended is not None
        
        # Verificar que o workflow Ã© adequado para a solicitaÃ§Ã£o
        assert any(platform in recommended.platforms_supported for platform in integration_request.platforms)
        
        # Verificar disponibilidade de workflows
        available = get_available_workflows()
        assert isinstance(available, dict)
        assert len(available) >= 3  # Pelo menos os 3 predefinidos
        
        logger.info("âœ… IntegraÃ§Ã£o workflow-orquestrador funcionando")
    
    def test_workflow_selection_logic(self):
        """Testa lÃ³gica de seleÃ§Ã£o de workflows"""
        logger.info("ðŸ§ª Testando lÃ³gica de seleÃ§Ã£o...")
        
        # Casos de teste para diferentes cenÃ¡rios
        test_cases = [
            {
                "request": ContentRequest(
                    topic="Post rÃ¡pido",
                    platforms=["whatsapp"],
                    target_audience="Geral",
                    objective="ComunicaÃ§Ã£o rÃ¡pida",
                    deadline=datetime.now() + timedelta(minutes=30)
                ),
                "expected_quality": "basic",
                "max_time": 90
            },
            {
                "request": ContentRequest(
                    topic="EstratÃ©gia de marca premium para campanha oficial",
                    platforms=["instagram", "linkedin"],
                    target_audience="Executivos e investidores",
                    objective="Maximizar impacto da marca e conversÃµes estratÃ©gicas",
                    special_instructions="Campanha premium com alta qualidade visual e mÃºltiplas validaÃ§Ãµes"
                ),
                "expected_quality": "premium",
                "min_steps": 4
            }
        ]
        
        for case in test_cases:
            workflow = get_recommended_workflow(case["request"])
            
            if "expected_quality" in case:
                assert workflow.quality_level == case["expected_quality"]
            
            if "max_time" in case:
                assert workflow.estimated_time <= case["max_time"]
            
            if "min_steps" in case:
                assert len(workflow.steps) >= case["min_steps"]
        
        logger.info("âœ… LÃ³gica de seleÃ§Ã£o validada")

class TestWorkflowStatistics:
    """Testes de estatÃ­sticas e mÃ©tricas de workflows"""
    
    def test_workflow_stats_initialization(self):
        """Testa inicializaÃ§Ã£o das estatÃ­sticas"""
        logger.info("ðŸ§ª Testando inicializaÃ§Ã£o de estatÃ­sticas...")
        
        # Verificar estrutura inicial
        stats = workflow_manager.get_workflow_stats()
        assert isinstance(stats, dict)
        
        # Por ser sistema novo, pode estar vazio
        # Mas estrutura deve estar preparada
        
        logger.info("âœ… EstatÃ­sticas inicializadas")
    
    def test_workflow_stats_structure(self):
        """Testa estrutura das estatÃ­sticas"""
        logger.info("ðŸ§ª Testando estrutura de estatÃ­sticas...")
        
        # Simular atualizaÃ§Ã£o de estatÃ­sticas
        test_execution = WorkflowExecution(
            workflow_id="test_123",
            config=workflow_manager.predefined_workflows[WorkflowType.STANDARD],
            context=ExecutionContext(
                request=ContentRequest(
                    topic="Teste",
                    platforms=["instagram"],
                    target_audience="Teste",
                    objective="Teste"
                ),
                status=OrchestrationStatus.IDLE
            ),
            start_time=datetime.now()
        )
        
        test_result = CrewResult(
            request=test_execution.context.request,
            success=True,
            final_content="ConteÃºdo de teste",
            agent_results=[],
            total_execution_time=120.0,
            approval_status="approved"
        )
        
        # Atualizar estatÃ­sticas
        workflow_manager._update_workflow_stats(test_execution, test_result)
        
        # Verificar estrutura criada
        stats = workflow_manager.get_workflow_stats()
        
        if "Standard Content Creation" in stats:
            workflow_stats = stats["Standard Content Creation"]
            expected_keys = [
                "total_executions",
                "successful_executions",
                "avg_execution_time",
                "avg_quality_score",
                "platform_usage",
                "use_case_performance"
            ]
            
            for key in expected_keys:
                assert key in workflow_stats
        
        logger.info("âœ… Estrutura de estatÃ­sticas validada")

# FunÃ§Ãµes de utilidade para testes
class TestWorkflowUtils:
    """UtilitÃ¡rios para testes de workflows"""
    
    @staticmethod
    def create_test_workflow_config() -> WorkflowConfig:
        """Cria configuraÃ§Ã£o de workflow para testes"""
        return WorkflowConfig(
            name="Test Workflow",
            description="Workflow criado para testes unitÃ¡rios",
            steps=[WorkflowStep.WRITING, WorkflowStep.EDITING],
            agents_required=["writer", "editor"],
            estimated_time=60,
            quality_level="basic",
            platforms_supported=["whatsapp", "instagram"],
            use_cases=["Testes automatizados"],
            validation_rules={
                "min_content_length": 10,
                "max_content_length": 1000
            }
        )
    
    @staticmethod
    def create_test_requests() -> List[ContentRequest]:
        """Cria lista de solicitaÃ§Ãµes variadas para testes"""
        return [
            ContentRequest(
                topic="Dica rÃ¡pida de produtividade",
                platforms=["whatsapp"],
                target_audience="Trabalhadores",
                objective="Ajuda rÃ¡pida"
            ),
            ContentRequest(
                topic="AnÃ¡lise completa de mercado e estratÃ©gias avanÃ§adas",
                platforms=["instagram", "linkedin", "facebook"],
                target_audience="Executivos e especialistas em marketing",
                objective="EducaÃ§Ã£o estratÃ©gica e geraÃ§Ã£o de leads qualificados",
                tone="Profissional e autoritativo",
                special_instructions="Incluir dados estatÃ­sticos, anÃ¡lises comparativas e recomendaÃ§Ãµes estratÃ©gicas detalhadas"
            ),
            ContentRequest(
                topic="Comunicado urgente sobre atualizaÃ§Ã£o",
                platforms=["whatsapp", "instagram"],
                target_audience="UsuÃ¡rios da plataforma",
                objective="Informar rapidamente",
                deadline=datetime.now() + timedelta(hours=2)
            )
        ]
    
    @staticmethod
    def validate_workflow_recommendation(workflow: WorkflowConfig, request: ContentRequest) -> bool:
        """Valida se um workflow Ã© adequado para uma solicitaÃ§Ã£o"""
        try:
            # Verificar suporte Ã s plataformas
            platform_support = any(
                platform in workflow.platforms_supported 
                for platform in request.platforms
            )
            assert platform_support
            
            # Verificar que tem passos vÃ¡lidos
            assert len(workflow.steps) > 0
            assert len(workflow.agents_required) > 0
            
            # Verificar tempo estimado razoÃ¡vel
            assert 30 <= workflow.estimated_time <= 600  # Entre 30s e 10min
            
            return True
            
        except AssertionError:
            return False

if __name__ == "__main__":
    # ExecuÃ§Ã£o direta para testes rÃ¡pidos
    logger.info("ðŸ§ª Executando testes bÃ¡sicos de workflows...")
    
    test_manager = TestWorkflowManager()
    
    # Testes bÃ¡sicos
    test_manager.test_workflow_manager_initialization()
    test_manager.test_predefined_workflows_creation()
    test_manager.test_workflow_steps_configuration()
    
    # Teste de integraÃ§Ã£o
    test_integration = TestWorkflowIntegration()
    test_integration.test_orchestrator_initialization()
    
    logger.info("âœ… Testes bÃ¡sicos de workflows concluÃ­dos!")
    
    # Para executar todos os testes: pytest tests/test_workflows.py -v
